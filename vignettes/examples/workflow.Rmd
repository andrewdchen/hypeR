---
title: "Workflow for Co-Expression Modules"
vignette: >
  %\VignetteIndexEntry{Workflow for Co-Expression Modules}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE, messages=FALSE, warnings=FALSE}
knitr::opts_chunk$set(comment="", fig.align="center", fig.width=8.75)
library(WGCNA)
library(flashClust)
library(doParallel)
library(Biobase)
library(dplyr)
library(magrittr)
library(hypeR)
```

## Introduction
Often computational biologists must process, interpret, and share large amounts of biological data. A common example is interpreting gene co-expression modules across one or more phenotype, resulting in potentially hundreds of signatures to annotate. In this workflow example, we'll generate gene co-expression modules for each of four breast cancer subtypes and use __hypeR__ to annotate the results.

## Requirements
```{r, eval=FALSE}

library(hypeR)
library(WGCNA)
library(flashClust)
library(doParallel)
library(Biobase)
library(dplyr)
library(magrittr)

```

## Data
We're using publicly available RNA-seq data from breast cancer samples from [The Cancer Genome Atlas](https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga). The data has been normalized with DESeq2, log-transformed, and subtyped using [Genefu signatures](https://bioconductor.org/packages/release/bioc/html/genefu.html).

```{r}

brca <- readRDS("data/TCGA-BRCA-RNA-Seq-Expression-Set.rds")

```

Isolate tumor samples with subtypes LumA, LumB, Her2, and Basal.

```{r}

subtypes <- c("LA", "LB", "H2", "BL")
brca.tumors <- brca[, brca$subtype %in% subtypes]

```

```{r}

table(brca.tumors$subtype)
dim(brca.tumors)

```

## Filtering
We'll filter genes based on three conditions:

#### Annotated from experiment or a direct assay  

The following dataset for human and other species can be downloaded from [Gene Ontology]("http://current.geneontology.org/products/pages/downloads.html").

```{r}

annotations <- read.delim(file="data/Gene-Ontology-Human-Annotations.gaf", 
                          skip=31, 
                          header=FALSE, 
                          stringsAsFactors=FALSE)

genes.0 <- annotations %>%
           filter(V7 %in% c("EXP", "IDA")) %>%
           use_series(V3) %>%
           unique()

```

#### Non-zero expression in 1/5 of samples of each subtype  

```{r}

variable.genes <- list()
for (i in subtypes) {
    brca.tumors.sub <- brca.tumors[,brca.tumors$subtype == i]
    sub.exprs.mat <- Biobase::exprs(brca.tumors.sub)
    n.samples <- ncol(sub.exprs.mat)
    sub.genes.keep <- rowSums(sub.exprs.mat != 0)/n.samples >= 0.2
    variable.genes[[i]] <- rownames(sub.exprs.mat)[sub.genes.keep]
}
genes.1 <- Reduce(intersect,  variable.genes)

```

#### Non-zero variance in each subtype  

```{r}

variable.genes <- list()
for (i in subtypes) {
    brca.tumors.sub <- brca.tumors[,brca.tumors$subtype == i]
    sub.exprs.mat <- Biobase::exprs(brca.tumors.sub)
    n.samples <- ncol(sub.exprs.mat)
    sub.genes.keep <- apply(sub.exprs.mat, 1, var) != 0
    variable.genes[[i]] <- rownames(sub.exprs.mat)[sub.genes.keep]
}
genes.2 <- Reduce(intersect,  variable.genes)

```

```{r}

genes.keep <- intersect(genes.0, intersect(genes.1, genes.2))
brca.tumors.filtered <- brca.tumors[genes.keep,]
dim(brca.tumors.filtered)

```

## Co-Expression
We'll write a wrapper function for the [Weighted Gene Co-Expression Analysis](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/) R package to define gene co-expression modules for each subtype.

```{r, eval=FALSE}

wgcna <- function(eset, subtype) {

    # Format data input
    counts <- t(exprs(eset[,eset$subtype == subtype]))
    
    # Choose a threshold which leads to best fit for scale-free topology
    threshtest <- pickSoftThreshold(counts, powerVector=1:10)
    tmax <- max(threshtest$fitIndices$SFT.R.sq)
    threshold <- threshtest$fitIndices[threshtest$fitIndices$SFT.R.sq == tmax, "Power"]    
    
    # Create adjacency matrix based on gene co-expression 
    adjacencyMatrix <- adjacency(counts, power=threshold) %>% 
                       TOMsimilarity()
    
    # Identify modules using dynamic tree cut
    modules <- hclust(as.dist(1-adjacencyMatrix), method="complete") %>%
               cutreeDynamic(distM=1-adjacencyMatrix, 
                             deepSplit=2, 
                             pamRespectsDendro=FALSE, 
                             minClusterSize=20)
    
    # Calculate eigengenes
    eigengenes <- moduleEigengenes(expr=counts, colors=modules)$eigengenes

    # Merge modules with similar eigengenes
    modules <- mergeCloseModules(exprData=counts, 
                                 colors=modules, 
                                 MEs=eigengenes, 
                                 cutHeight=0.25)
    
    # Create a list of modules    
    modulesList <- vector("list", length=length(unique(modules$colors)))
    
    # Assign genes to correct module
    uniqueModules <- sort(unique(modules$colors))
    for(i in seq(length(uniqueModules))){
        pindex <- which(modules$colors==uniqueModules[i])
        modulesList[[i]] <- rownames(eset)[pindex]
    }
    names(modulesList) <- paste0('M', seq(0, length(modulesList)-1))
    
    return(modulesList)
}

```

The dataset we are saving is a list of gene co-expression modules defined for each subtype.

```{r, eval=FALSE}

# Parallel computation
registerDoParallel(cores=3)
getDoParWorkers()

# Co-expression modules
hypdat <- list("LumA"  = wgcna(brca.tumors.filtered, subtype="LA"),
               "LumB"  = wgcna(brca.tumors.filtered, subtype="LB"),
               "Her2"  = wgcna(brca.tumors.filtered, subtype="H2"),
               "Basal" = wgcna(brca.tumors.filtered, subtype="BL"))

saveRDS(hypdat, "data/TCGA-BRCA-Co-Expression-Modules.rds")

```

## Using hypeR

We'd like to see if any modules are enriched with genes associated with known biological processes. We can use __hypeR__ to perform geneset enrichment and efficiently visualize, analyze, and share the results. When dealing with many genesets, itâ€™s often useful to understand the relationships between them. This allows researchers to summarize many enriched pathways as more general biological processes. To do this, we rely on curated relationships defined between them. For example, [REACTOME](https://reactome.org/) conveniently defines their genesets in a [hiearchy of pathways](https://reactome.org/PathwayBrowser/). This data can be formatted into a relational genesets object.

```{r, eval=FALSE}

rgsets <- hyperdb_fetch(type="rgsets", "REACTOME")

```

```{r}

hypdat <- readRDS("data/TCGA-BRCA-Co-Expression-Modules.rds")
str(hypdat)

```

By default, `hypeR()` recognizes a single signature or a named list of signatures. Because we are using a nested list of signatures, we can use the `lapply` function to return a list of `multihyp` objects, which can be directly passed to `hyp_to_rmd()` for generating reports.

```{r, eval=FALSE}

lmultihyp_obj <- lapply(hypdat, hypeR, rgsets, test="hypergeometric", bg=36812, fdr_cutoff=0.05)

```

We can pass a list of `multihyp` objects directly to `hyp_to_rmd()`, which will accept multiple formats, including a single `hyp` or `multihyp` object as well as a list of either, including a list of `hyp` or `multihyp` objects together. When a list of `multihyp` objects are passed for example, each experiment will become its own section, while each signature becomes its own tab within that section. In this example, each section is linked to a subtype, and each tab within that section holds the enrichment results for a specific co-expression module.

```{r, eval=FALSE}

hyp_to_rmd(lmultihyp_obj,
           file_path="TCGA-BRCA-Workflow-Report.rmd",
           title="Hyper Enrichment (hypeR)",
           subtitle="Co-Expression Modules for Breast Cancer Subtypes",
           author="Anthony Federico, Stefano Monti",
           show_dots=F,
           show_emaps=F,
           show_hmaps=T,
           show_tables=T)

```

This report can be viewed at https://montilab.github.io/hypeR-reporting.
